#include "Packet.h"
#include <windows.h>
#include <mswsock.h>
#include <iostream>
#include <unordered_map>
#include <format>  // C++20 format 사용
#include "Packet.h"

#pragma comment(lib, "ws2_32.lib")

#define MAX_CLIENTS 2
#define SERVER_PORT 5000
#define MAX_PACKET_SIZE 1024  // IOContext의 buffer 크기와 동일하게 설정

HANDLE g_hIOCP;  // IOCP 핸들 전역 변수 추가
int g_nextClientID = 1;  // 클라이언트 ID 카운터도 필요

struct ClientInfo {
    SOCKET socket;
    int clientID;
    PacketPlayerUpdate lastUpdate;  // 마지막으로 업데이트된 위치 정보를 패킷 형태로 저장
};

// 명시적으로 타입을 지정
std::unordered_map<int, struct ClientInfo> g_clients;  // 클라이언트 ID를 키로 사용하는 맵

// IOCP 작업을 위한 구조체 추가
struct IOContext {
    OVERLAPPED overlapped;
    WSABUF wsaBuf;
    char buffer[1024];
    DWORD flags;
};

void BroadcastPacket(const void* packet, int size, int excludeID = -1) {
    PacketHeader* header = (PacketHeader*)packet;
    if (size < sizeof(PacketHeader) || size != header->size) {
        std::cout << "[Error] Invalid packet size in broadcast" << std::endl;
        return;
    }

    std::cout << "\n[Broadcast] Type: " << header->type << ", Size: " << size << std::endl;
    std::cout << "  -> Excluding client ID: " << excludeID << std::endl;

    if (header->type == PACKET_PLAYER_UPDATE) {
        PacketPlayerUpdate* pkt = (PacketPlayerUpdate*)packet;
        std::cout << "  -> Broadcasting position: (" << pkt->x << ", " << pkt->y << ", " << pkt->z
            << "), Rotation: " << pkt->rotY << std::endl;
    }

    int targetCount = 0;  // 실제 전송 대상 클라이언트 수
    for (auto& [id, client] : g_clients) {
        if (id != excludeID) targetCount++;
    }

    int sentCount = 0;
    for (auto& [id, client] : g_clients) {
        if (id == excludeID) continue;
        
        int result = send(client.socket, (char*)packet, size, 0);
        if (result == SOCKET_ERROR) {
            int error = WSAGetLastError();
            std::cout << "  -> Failed to send to client " << id << " (Error: " << error << ")" << std::endl;
            
            if (error != WSAEWOULDBLOCK) {
                closesocket(client.socket);
                g_clients.erase(id);
            }
        }
        else {
            std::cout << "  -> Successfully sent to client " << id << std::endl;
            sentCount++;
        }
    }
    std::cout << "  -> Total broadcasts sent: " << sentCount << "/" << targetCount << std::endl;
}

DWORD WINAPI WorkerThread(LPVOID lpParam) {
    while (true) {
        DWORD bytesTransferred;
        ULONG_PTR completionKey;
        OVERLAPPED* pOverlapped;
        
        BOOL result = GetQueuedCompletionStatus(g_hIOCP, &bytesTransferred, &completionKey, &pOverlapped, INFINITE);
        int clientID = (int)completionKey;
        
        if (!pOverlapped) {
            continue;
        }
        
        IOContext* ioContext = CONTAINING_RECORD(pOverlapped, IOContext, overlapped);
        
        if (g_clients.find(clientID) == g_clients.end()) {
            if (ioContext) delete ioContext;
            continue;
        }
        
        if (!result || bytesTransferred == 0) {
            std::cout << "\n[Disconnect] Client ID " << clientID << " disconnected" << std::endl;
            closesocket(g_clients[clientID].socket);
            g_clients.erase(clientID);
            std::cout << "  -> Active clients remaining: " << g_clients.size() << std::endl;
            delete ioContext;
            continue;
        }

        // 패킷 처리
        PacketHeader* header = (PacketHeader*)ioContext->buffer;
        if (header->size == 0 || header->size > MAX_PACKET_SIZE || header->type <= 0) {
            std::cout << "[Error] Invalid packet header - Size: " << header->size 
                      << ", Type: " << header->type << std::endl;
            continue;
        }

        if (bytesTransferred < sizeof(PacketHeader)) {
            std::cout << "[Error] Invalid packet size (smaller than header)" << std::endl;
            continue;
        }

        // 완전한 패킷을 수신했는지 확인
        if (bytesTransferred < header->size) {
            std::cout << "[Error] Incomplete packet received" << std::endl;
            continue;
        }

        std::cout << "\n[Receive] From client " << clientID << std::endl;
        std::cout << "  -> Packet type: " << header->type << std::endl;
        std::cout << "  -> Packet size: " << header->size << std::endl;

        switch (header->type) {
            case PACKET_PLAYER_UPDATE: {
                if (header->size != sizeof(PacketPlayerUpdate)) {
                    std::cout << "[Error] Invalid PLAYER_UPDATE packet size" << std::endl;
                    break;
                }
                PacketPlayerUpdate* pkt = (PacketPlayerUpdate*)ioContext->buffer;
                pkt->clientID = clientID;
                g_clients[clientID].lastUpdate = *pkt;
                BroadcastPacket(pkt, sizeof(PacketPlayerUpdate), clientID);
                break;
            }
            case PACKET_PLAYER_SPAWN: {
                if (header->size != sizeof(PacketPlayerSpawn)) {
                    std::cout << "[Error] Invalid PLAYER_SPAWN packet size" << std::endl;
                    break;
                }
                // 스폰 패킷 처리 로직 추가
                PacketPlayerSpawn* pkt = (PacketPlayerSpawn*)ioContext->buffer;
                BroadcastPacket(pkt, sizeof(PacketPlayerSpawn), clientID);
                break;
            }
            default:
                std::cout << "  -> Unknown packet type" << std::endl;
                break;
        }

        // 다음 수신 준비
        memset(ioContext->buffer, 0, sizeof(ioContext->buffer));  // 버퍼 초기화 추가
        memset(&ioContext->overlapped, 0, sizeof(OVERLAPPED));
        ioContext->wsaBuf.len = sizeof(ioContext->buffer);
        ioContext->flags = 0;

        DWORD recvBytes;
        if (WSARecv(g_clients[clientID].socket, &ioContext->wsaBuf, 1, &recvBytes,
            &ioContext->flags, &ioContext->overlapped, NULL) == SOCKET_ERROR) {
            int error = WSAGetLastError();
            if (error != ERROR_IO_PENDING && error != WSAEWOULDBLOCK) {
                std::cout << "[Error] WSARecv failed with error: " << error << std::endl;
                delete ioContext;
                continue;
            }
        }
    }
    return 0;  // 정상 종료 시 0 반환
}

// 클라이언트 연결 시 초기 수신 설정
void StartReceive(SOCKET clientSocket, int clientID) {
    IOContext* ioContext = new IOContext();
    memset(&ioContext->overlapped, 0, sizeof(OVERLAPPED));
    ioContext->wsaBuf.buf = ioContext->buffer;
    ioContext->wsaBuf.len = sizeof(ioContext->buffer);
    ioContext->flags = 0;

    DWORD recvBytes;
    if (WSARecv(clientSocket, &ioContext->wsaBuf, 1, &recvBytes,
        &ioContext->flags, &ioContext->overlapped, NULL) == SOCKET_ERROR) {
        int error = WSAGetLastError();
        if (error != ERROR_IO_PENDING && error != WSAEWOULDBLOCK) {
            std::cout << "[Error] Initial WSARecv failed with error: " << error << std::endl;
            delete ioContext;
            return;
        }
    }
}

void BroadcastNewPlayer(int newClientID) {
    std::cout << "\n[BroadcastNewPlayer] New client ID: " << newClientID << std::endl;
    
    // 새 클라이언트에게 기존 클라이언트들의 ID만 전송
    for (const auto& [id, client] : g_clients) {
        if (id != newClientID) {
            PacketPlayerSpawn existingClientPacket;
            existingClientPacket.header.type = PACKET_PLAYER_SPAWN;
            existingClientPacket.header.size = sizeof(PacketPlayerSpawn);
            existingClientPacket.playerID = id;
            
            send(g_clients[newClientID].socket, (char*)&existingClientPacket, sizeof(existingClientPacket), 0);
        }
    }
    
    // 기존 클라이언트들에게 새 클라이언트 ID 전송
    PacketPlayerSpawn newClientPacket;
    newClientPacket.header.type = PACKET_PLAYER_SPAWN;
    newClientPacket.header.size = sizeof(PacketPlayerSpawn);
    newClientPacket.playerID = newClientID;
    
    BroadcastPacket(&newClientPacket, sizeof(newClientPacket), newClientID);
}

void ProcessNewClient(SOCKET clientSock) {
    int clientID = g_nextClientID++;
    std::cout << "[Info] ProcessNewClient" << std::endl;
    
    ClientInfo newClient;
    newClient.socket = clientSock;
    newClient.clientID = clientID;
    newClient.lastUpdate = { 0 };
    
    g_clients[clientID] = newClient;
    
    if (g_clients.find(clientID) == g_clients.end()) {
        std::cout << "[Error] Failed to add client to map" << std::endl;
        return;
    }
    
    std::cout << "[ProcessNewClient] " << clientID << " added to map. Total clients: " << g_clients.size() << std::endl;
    
    CreateIoCompletionPort((HANDLE)clientSock, g_hIOCP, clientID, 0);
    
    // 새 클라이언트에게 자신의 ID 전송
    PacketPlayerSpawn spawnPacket;
    spawnPacket.header.type = PACKET_PLAYER_SPAWN;
    spawnPacket.header.size = sizeof(PacketPlayerSpawn);
    spawnPacket.playerID = clientID;
    
    if (send(clientSock, (char*)&spawnPacket, sizeof(spawnPacket), 0) == SOCKET_ERROR) {
        std::cout << "[Error] Failed to send spawn packet to new client" << std::endl;
        return;
    }
    
    // 다른 클라이언트들과 정보 교환
    BroadcastNewPlayer(clientID);
    
    StartReceive(clientSock, clientID);
}

int main() {
    std::cout << "[Server] Starting server on port " << SERVER_PORT << std::endl;

    WSADATA wsaData;
    WSAStartup(MAKEWORD(2, 2), &wsaData);

    SOCKET listenSock = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
    SOCKADDR_IN serverAddr = { 0 };
    serverAddr.sin_family = AF_INET;
    serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
    serverAddr.sin_port = htons(SERVER_PORT);

    bind(listenSock, (SOCKADDR*)&serverAddr, sizeof(serverAddr));
    listen(listenSock, SOMAXCONN);

    g_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0);

    for (int i = 0; i < 2; ++i) {
        CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
    }

    while (true) {
        SOCKET clientSock = accept(listenSock, NULL, NULL);
        ProcessNewClient(clientSock);
    }

    closesocket(listenSock);
    WSACleanup();
    return 0;
}